#pragma config(Sensor, in1,    liftPos,        sensorPotentiometer)
#pragma config(Sensor, in2,    tiltPos,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  HappyLed,       sensorLEDtoVCC)
#pragma config(Motor,  port2,           rightfront,    tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           leftfront,     tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           leftrear,      tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           rightrear,     tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port6,           leftshooter,   tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port7,           rightshooter,  tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Code to run Kitt Peak antenna testing robot
// Designed for tangential driving. has ball lift and tilt mechs.


#pragma platform(VEX)  // tell it not to assume vex iq

//Global Constants
int const dt = 20;  // number of milliseconds per each control loop
int const maxSteer = 50;  // percent of drive to apply to steering

//Global Variables
int liftSpeed = 0;//The speed of the lift.
int tiltSpeed = 0;//The speed of the tilter.
int driveSpeed = 0;//The forward drive speed.
int turnCoef = 0;//The turning amount.
int pot_lift = 0;  // the pot that reads the lift up/down wheel
int top_lift = 1700;  // upper end with ball clear to drive; full up=2300
int safe_lift = 1500;  // safe to drive
int bottom_lift = 200; // ball on mirror; full down = 0
int pot_tilt = 0;  // the pot that reads the tilt position
int top_tilt = 3500;  // center of dish
int bottom_tilt = 2000; // edge of dish

//Functions;

//CALCODE Modifies the inout to create a linear speed curve.
int linearize(int vel){
	int pwm;
	int linear[129] = {0, 0, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20,
		21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 24, 24, 24, 25, 25, 25,
		25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 29, 29, 29, 29, 30, 30, 30,
		31, 31, 31, 32, 32, 33, 33, 33, 34, 34, 35, 35, 36, 36, 36, 37, 37, 38,
		38, 39, 39, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 45, 45, 46, 47, 48,
		49, 49, 50, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 64, 65, 66,
		67, 68, 69, 70, 72, 73, 75, 76, 77, 79, 81, 83, 84, 84, 85, 85, 86, 86,
		87, 87, 88, 90, 96, 105, 105};
	if(vel > 127) {vel = 127;}
	if(vel < -127) {vel = -127;}
	if (vel < 0){
		pwm = -linear[-vel];
		} else {
		pwm = linear[vel];
	}
	return pwm;
}

//CALCODE Implements a deadband so it doesn't move without moving a joystick.
int deadband(int vel) {
	return (abs(vel) < 24) ? 0: vel;
}

//CALCODE Limits the acceleration I think...........
int acc_limit(int input, int old, int max_acc)
{
	if ((input - old) > max_acc) {input += max_acc;}
	if ((input - old) < -max_acc) {input -= max_acc;}
	return (input);
}

//Controls the lift.
task lift_control
{
	while(true)
	{
		pot_lift = SensorValue[liftPos];
		motor[leftshooter] = linearize(liftSpeed);
		wait1Msec(dt);
	}
}

//Controls the tilt.
task tilt_control
{
	while(true)
	{
		pot_tilt = SensorValue[tiltPos];
		motor[rightshooter] = linearize(tiltSpeed);
		wait1Msec(dt);
	}
}

//CALCODE Drives the robot.
task Drive_control
{
	while(true)
	{
		if(driveSpeed > 127) {driveSpeed = 127;}
		if(driveSpeed < -127) {driveSpeed = -127;}
		if(turnCoef > 127) {turnCoef = 127;}
		if(turnCoef < -127) {turnCoef = -127;}
		if (pot_lift < safe_lift)
		{
			turnCoef = 0;
			driveSpeed = 0;  // prevent dragging the ball on the mirror
		}
		motor[leftfront] = motor[leftrear]  = linearize(driveSpeed + (maxSteer*turnCoef/100));
		motor[rightfront] = motor[rightrear] = linearize(driveSpeed - (maxSteer*turnCoef/100));
		wait1Msec(dt);
	}
}


//Called to run the robot.
task main()
{
	startTask (Drive_control);
	startTask (lift_control);
	startTask (tilt_control);

	while (true)
	{
		driveSpeed = deadband(vexRT[Ch3]);
		turnCoef = deadband(vexRT[Ch1]);
		liftSpeed = 0;
		tiltSpeed = 0;

		if (pot_lift > bottom_lift)  // turn on green light when ball on mirror
			SensorValue[HappyLed] = false;
		else
			SensorValue[HappyLed] = true;

		if(vexRT[Btn6D] && (pot_lift > bottom_lift))
		{
			liftSpeed = 0 -(pot_lift - bottom_lift) /3;
			if (liftSpeed > 100)	liftSpeed = 100;
		}
		if(vexRT[Btn6U] && (pot_lift < top_lift))
		{
			liftSpeed = 0 -(pot_lift - top_lift)/3;
			if (liftSpeed < -100)	liftSpeed = -100;
		}

		if(vexRT[Btn5D] && (pot_tilt > bottom_tilt))
		{
			tiltSpeed = (pot_tilt - bottom_tilt) /3;
			if (tiltSpeed > 100)	tiltSpeed = 100;
		}
		if(vexRT[Btn5U] && (pot_tilt < top_tilt))
		{
			tiltSpeed = (pot_tilt - top_tilt)/3;
			if (tiltSpeed < -100)	tiltSpeed = -100;
		}
		wait1Msec(dt);
	}

}
